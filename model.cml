ContextMap RayCharge
{
	contains RealizacaoDeRecargaContext
    contains CadastroEControleDeFornecedoresContext
    contains CadastroEControleDeMotoristasContext
    contains AutenticacaoEAutorizacaoContext
    contains NotificacoesContext
    contains RelatoriosSobreAsEstacoesDeRecargaContext

	// revisar relacoes

	// all shared kernel
	CadastroEControleDeFornecedoresContext [S] -> [C] RealizacaoDeRecargaContext
	CadastroEControleDeMotoristasContext [S] -> [C] RealizacaoDeRecargaContext

	CadastroEControleDeFornecedoresContext [P] <-> [P] RelatoriosSobreAsEstacoesDeRecargaContext
	NotificacoesContext [P] <-> [P] RealizacaoDeRecargaContext
	NotificacoesContext [P] <-> [P] CadastroEControleDeFornecedoresContext
    NotificacoesContext [P] <-> [P] CadastroEControleDeMotoristasContext
    NotificacoesContext [P] <-> [P] AutenticacaoEAutorizacaoContext

	// all open host
	AutenticacaoEAutorizacaoContext [U,OHS] -> [D, CF] CadastroEControleDeFornecedoresContext
	AutenticacaoEAutorizacaoContext [U,OHS] -> [D, CF] CadastroEControleDeMotoristasContext
	AutenticacaoEAutorizacaoContext [U,OHS] -> [D, CF] RealizacaoDeRecargaContext
}

/* Definição dos Contextos */
BoundedContext CadastroEControleDeFornecedoresContext implements CadastroEControleDeFornecedoresDomain
{
	type = FEATURE
	domainVisionStatement = "O contexto de cadastro e controle de Fornecedores é responsável por armazenar os dados dos Fornecedores e suas Estações."
	responsibilities = "Fornecedor"

	Aggregate Fornecedor
	{
		Entity Fornecedor
		{
			aggregateRoot

			- Usuario usuarioFornecedor
            String nomeFornecedor
            - List <EstacaoDeRecarga> estacoesDeRecarga
            - List <Agendamento> historicoDeUso
		}

		Service AlteracoesContaFornecedor
		{
			int deletarConta(@Usuario usuarioFornecedor);
			int alterarNomeFornecedor(String novoNome);
		}

		Entity EstacaoDeRecarga
        {
        	int quantidadeDeCarregadores
            - HorarioDisponivel horarioFuncionamento
            - Endereco enderecoEstacao
            boolean statusEstacao // lotada ou com vaga
            String nomeDaEstacao
			- Fornecedor fornecedor
            int precoReserva
            int precoPKwH

            - List <HorarioDisponivel> horariosDisponiveis

            - List <Agendamento> historicoDeUso
        }

		Service AlteracoesEstacao
		{
			int alterarQuantidadeCarregadores(int novaQuantidade);
			int alterarHorarioFuncionamento(@HorarioDisponivel novoHorario);
			String alterarNomeEstacao(String novoNome);
			int alterarPrecoReserva(int novoPreco);
			int alterarPrecoPKwH(int novoPreco);
			int deletarEstacao(@EstacaoDeRecarga estacao);
			int adicionarEstacao(int quantidadeDeCarregadores, @HorarioDisponivel horarioFuncionamento, @Endereco enderecoEstacao, String nomeDaEstacao, int precoReserva, int precoPKwH);
		}

        ValueObject HorarioDisponivel
        {
            DateTime inicioAgendamento
            DateTime fimAgendamento
        }

		ValueObject Endereco
		{
			String cep
			String rua
			String bairro
			String cidade
			int numero
		}
	}
}

BoundedContext CadastroEControleDeMotoristasContext implements CadastroEControleDeMotoristasDomain
{
	type = FEATURE
	domainVisionStatement = "O contexto de cadastro e controle dos Motoristas é responsável por armazenar os dados dos Motoristas e seus Veículos."
	responsibilities = "Motorista"

	Aggregate Motorista
    {
        Entity Motorista
        {
            aggregateRoot

            String nomeMotorista
            - List <Veiculo> veiculos
            - List <Agendamento> historicoDeUso
            - Usuario usuarioMotorista
        }
    	Service AlteracoesContaMotorista
		{
			int deletarConta(@Usuario usuarioMotorista);
			int alterarNomeMotorista(String novoNome);
		}
        Entity Veiculo
        {
            String placaVeiculo
            - List <Agendamento> historicoDeUso
            String nomeVeiculo
            - Motorista motorista
        }
        Service AlteracoesVeiculo
		{
			int deletarVeiculo(@Veiculo veiculo);
			int alterarNomeVeiculo(String novoNome);
			int alterarPlacaVeiculo(String novaPlaca);
			int adicionarVeiculo(String placaVeiculo, String nomeVeiculo);
		}
    }
}

BoundedContext RealizacaoDeRecargaContext implements RealizacaoDeRecargaDomain
{
	type = FEATURE
	domainVisionStatement = "O contexto de Realizar Recarga é responsável por mostrar para os Motoristas as Estações Próximas e permitir que realizem Agendamentos."
	responsibilities = "Agenda"

	Aggregate ConsultaEstacoesProximas
	{
		 Entity ConsultaEstacoesProximas
		 {
		 	aggregateRoot
		 	- Endereco enderecoAtualMotorista
			int raioDeBusca
			- List <EstacaoDeRecarga> estacoesProximas
		 }

		 Service SetNovoRaioDeBusca
		 {
		 	int setNovoRaio(int novoRaio);
		 }
	}

	Aggregate  Agendamento
    {
        Entity Agendamento
        {
            aggregateRoot

            - IdAgendamento idAgendamento
            int codigoLiberacaoCarregador
            - HorarioDisponivel horarioAgendamento

            boolean statusAgendamento // ativo ou cancelado

            - EstacaoDeRecarga estacaoDeRecarga
            - Motorista motorista
            - Veiculo veiculo
            - ConsultaEstacoesProximas estacoesProximas
        }
        ValueObject IdAgendamento
        {
            int idAgendamento key
        }

		Service ServicoAgendamento
		{
			int realizarAgendamento(@HorarioDisponivel horarioAgendamento, @Veiculo veiculo, @EstacaoDeRecarga estacao); // retornar o id do agendamento
			int cancelarAgendamento(int idAgendamento); // retornar o id do agendamento
		}
		Service GetCodigoLiberacao
		{
			int getCodigoLiberacao(@Agendamento idAgendamento);
		}
	}

	Aggregate Avaliacao
	{
		Entity Avaliacao
		{
			aggregateRoot

			- IdAgendamento idAgendamento
			- Avaliacoes avaliacaoDada
			String descricaoExperiencia nullable
		}
		enum Avaliacoes
		{
			UM, DOIS, TRES, QUATRO, CINCO
		}
	}
}

BoundedContext AutenticacaoEAutorizacaoContext implements AutenticacaoEAutorizacaoDomain
{
	type = APPLICATION
	domainVisionStatement = "O contexto de gerenciamento de autenticacao é uma aplicação que valida o usuário que acessa o sistema."

	Aggregate Autenticacao
    {
        Entity Usuario
        {
            aggregateRoot

            String login
            String senha
            boolean tipoUsuario // Motorista ou Fornecedor
        }

    	Service NovosUsuarios
    	{
    		// Nao criamos a funcao de deletar contas aqui pois os subdominios especificos realizam isso
    		int criarConta(String login, String senha, boolean tipoUsuario);
    	}
    }
}

BoundedContext NotificacoesContext implements NotificacoesDomain
{
    Aggregate Notificacao
    {
    	enum TipoNotificacoes
    	{
    		CONFIRMAR_CANCELAMENTO, INFORMAR_CANCELAMENTO, SISTEMA
    	}

        Entity Notificacao
        {
            - List <Usuario> destinatarios
            - Usuario origem nullable
			- TipoNotificacoes tipoNotificacao
            String mensagem
        }
    }
}

BoundedContext RelatoriosSobreAsEstacoesDeRecargaContext implements RelatoriosSobreAsEstacoesDeRecargaDomain
{
	Aggregate RelatorioDesempenho
	{
		Entity Desempenho
		{
			aggregateRoot
			- EstacaoDeRecarga estacaoDeRecarga
			- PeriodoDeAnalise periodoDeAnalise
		}

		ValueObject PeriodoDeAnalise
		{
			DateTime inicioDaAnalise
			DateTime fimDaAnalise
		}
	}
}

/* Descrição do Domínio e Subdomínios */
Domain RayChargeDomain
{
	// Subdomínio de Cadastro e Controle dos Fornecedores (genérico)
    Subdomain CadastroEControleDeFornecedoresDomain
    {
        type = GENERIC_SUBDOMAIN
		domainVisionStatement = "Subdomínio responsável por armazenar tudo referente ao Fornecedor e Estações de Recarga"
    }

	// Subdomínio de Cadastro e Controle dos Motoristas (genérico)
    Subdomain CadastroEControleDeMotoristasDomain
    {
        type = GENERIC_SUBDOMAIN
		domainVisionStatement = "Subdomínio responsável por armazenar tudo referente ao Motorista e Veículos da recarga"
    }

	// Subdomínio de Consulta e Agendamento de Recarga (principal)
    Subdomain RealizacaoDeRecargaDomain
    {
        type = CORE_DOMAIN
		domainVisionStatement = "Subdomínio responsável por mostrar para os Motoristas as Estações Próximas e permitir que realizem Agendamentos."
    }

	// Subdomínio de Autenticação e Autorização (suporte)
    Subdomain AutenticacaoEAutorizacaoDomain
    {
        type = SUPPORTING_DOMAIN
		domainVisionStatement = "Subdomínio responsável pela autenticação e autorização de Motoristas e Fornecedores"
    }

	// Subdomínio de Notificações (suporte)
    Subdomain NotificacoesDomain
    {
        type = SUPPORTING_DOMAIN
		domainVisionStatement = "Subdomínio responsável por enviar alertas e atualizações aos Motoristas e Fornecedores em resposta a eventos específicos que ocorrem no sistema"
    }

	// verificar necessidade
	// Subdomínio de Monitoramento de Desempenho das Estações de Recarga (suporte)
    Subdomain RelatoriosSobreAsEstacoesDeRecargaDomain
    {
        type = SUPPORTING_DOMAIN
		domainVisionStatement = "Subdomínio responsável por informar ao Fornecedor sobre o desempenho das suas Estações de recarga"
    }
}