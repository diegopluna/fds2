ContextMap RayCharge
{
	contains ConsultaEAgendamentoDeRecargaContext
    contains CadastroEControleDeFornecedoresContext
    contains CadastroEControleDeMotoristasContext
    contains AutenticacaoEAutorizacaoContext
    contains NotificacoesContext

	// all shared kernel
	CadastroEControleDeFornecedoresContext [S] -> [C] ConsultaEAgendamentoDeRecargaContext
	CadastroEControleDeMotoristasContext [S] -> [C] ConsultaEAgendamentoDeRecargaContext

	NotificacoesContext [P] <-> [P] ConsultaEAgendamentoDeRecargaContext
	NotificacoesContext [P] <-> [P] CadastroEControleDeFornecedoresContext
    
	// all open host
	AutenticacaoEAutorizacaoContext [U,OHS] -> [D, CF] CadastroEControleDeFornecedoresContext
	AutenticacaoEAutorizacaoContext [U,OHS] -> [D, CF] CadastroEControleDeMotoristasContext
	AutenticacaoEAutorizacaoContext [U,OHS] -> [D, CF] ConsultaEAgendamentoDeRecargaContext
}

/* Definição dos Contextos */
BoundedContext CadastroEControleDeFornecedoresContext implements CadastroEControleDeFornecedoresDomain
{
	type = FEATURE
	domainVisionStatement = "O contexto de cadastro e controle de Fornecedores é responsável por armazenar os dados dos Fornecedores e suas Estações."
	responsibilities = "Fornecedor"

	Aggregate Fornecedor
	{
		Entity Fornecedor
		{
			aggregateRoot

            String nomeFornecedor
            - List <EstacaoDeRecarga> estacoesDeRecarga
            - List <Agendamento> historicoDeUso
		}

		Entity EstacaoDeRecarga
        {
            - HorarioDisponivel horarioFuncionamento
            - Localizacao localizacaoEstacao
            boolean statusEstacao // lotada ou com vaga

            int precoReserva
            int precoPKwH

            - List <Carregador> carregadores
            - List <HorarioDisponivel> horariosDisponiveis

            - List <Agendamento> historicoDeUso
        }
		Entity Carregador
        {
            String nomeCarregador
            int tipoPlug
        }
        ValueObject HorarioDisponivel
        {
            DateTime inicioAgendamento
            DateTime fimAgendamento
        }
		// ver se iremos utilizar lat/long ou endereco
        ValueObject Localizacao
        {
            double longitude
            double latitude
        }
		ValueObject Endereco
		{
			String cep
			String rua
			String bairro
			String cidade
			int numero
		}
	}
}

BoundedContext CadastroEControleDeMotoristasContext implements CadastroEControleDeMotoristasDomain
{
	type = FEATURE
	domainVisionStatement = "O contexto de cadastro e controle de Motoristas é responsável por armazenar os dados dos Motoristas e de seus Veículos."
	responsibilities = "Motorista"
	
	Aggregate Motorista
    {
        Entity Motorista
        {
            aggregateRoot

            String nomeMotorista
            - List <Veiculo> veiculos
            - List <Agendamento> historicoDeUso
        }
        Entity Veiculo
        {
            String placaVeiculo
            - List <Agendamento> historicoDeUso
        }
    }
}

BoundedContext ConsultaEAgendamentoDeRecargaContext implements ConsultaEAgendamentoDeRecargaDomain
{
	type = FEATURE
	domainVisionStatement = "O contexto de gerenciamento de agendamentos é responsável por gerenciar todos os dados referentes ao processo de agendar as estações, inclusive oferecendo serviços de consulta e validação de datas e horarios."
	responsibilities = "Agenda"

	Aggregate  Agendamento
    {
        Entity Agendamento
        {
            aggregateRoot

            - IdAgendamento idAgendamento
            int codigoLiberacaoCarregador
            - HorarioDisponivel horarioAgendamento

            boolean statusAgendamento // ativo ou cancelado

            - EstacaoDeRecarga estacaoDeRecarga
            - Carregador carregador
            - Motorista motorista
            - Veiculo veiculo
        }
        ValueObject IdAgendamento
        {
            int idAgendamento key
        }

		// revisar
		Service RealizarAgendamento
		{
			int realizarAgendamento(DateTime horarioAgendamento, @Veiculo idVeiculo, @EstacaoDeRecarga idEstacao, @Carregador tipoPlug); // retornar o id do agendamento
		}
		Service GetCodigoLiberacao
		{
			int getCodigoLiberacao(@Agendamento idAgendamento);
		}
		Entity Recarga
		{
			- Agendamento idAgendamento
			double energiaUtilizada
		}
	}
}

BoundedContext AutenticacaoEAutorizacaoContext implements AutenticacaoEAutorizacaoDomain
{
	type = APPLICATION
	domainVisionStatement = "O contexto de gerenciamento de autenticacao é uma aplicação que valida o usuário que acessa o sistema."

	Aggregate Autenticacao
    {
        Entity Usuario
        {
            aggregateRoot

            String login
            String senha
            boolean tipoUsuario // Motorista ou Fornecedor
        }
    }
}

BoundedContext NotificacoesContext implements NotificacoesDomain
{
    Aggregate Notificacao
    {
        Entity Notificacao
        {
            - List <Usuario> destinatario
            - Usuario origem nullable
            int tipoNotificacao
            String mensagem
        }
    }
}

/* Descrição do Domínio e Subdomínios */
Domain RayChargeDomain
{
	// Subdomínio de Cadastro e Controle dos Fornecedores (genérico)
    Subdomain CadastroEControleDeFornecedoresDomain
    {
        type = GENERIC_SUBDOMAIN
		domainVisionStatement = "Subdomínio responsável por armazenar tudo referente ao Fornecedor, Estação e Carregadores da recarga"
    }

	// Subdomínio de Cadastro e Controle dos Motoristas (genérico)
    Subdomain CadastroEControleDeMotoristasDomain
    {
        type = GENERIC_SUBDOMAIN
		domainVisionStatement = "Subdomínio responsável por armazenar tudo referente ao Motorista e Veículos da recarga"
    }

	// Subdomínio de Consulta e Agendamento de Recarga (principal)
    Subdomain ConsultaEAgendamentoDeRecargaDomain
    {
        type = CORE_DOMAIN
		domainVisionStatement = "Subdomínio responsável por intermediar o Serviço e seu Histórico"
    }

	// Subdomínio de Autenticação e Autorização (suporte)
    Subdomain AutenticacaoEAutorizacaoDomain
    {
        type = SUPPORTING_DOMAIN
		domainVisionStatement = "Subdomínio responsável pela autenticação e autorização de Motoristas e Fornecedores"
    }

	// Subdomínio de Notificações (suporte)
    Subdomain NotificacoesDomain
    {
        type = SUPPORTING_DOMAIN
		domainVisionStatement = "Subdomínio responsável por enviar alertas e atualizações aos Motoristas e Fornecedores em resposta a eventos específicos que ocorrem no sistema"
    }

	// verificar necessidade
	// Subdomínio de Monitoramento de Desempenho das Estações de Recarga (suporte)
    Subdomain MonitoramentoDeDesempenhoDomain
    {
        type = SUPPORTING_DOMAIN
		domainVisionStatement = "Subdomínio responsável por informar ao Fornecedor sobre o desempenho das suas Estações de recarga"
    }
}